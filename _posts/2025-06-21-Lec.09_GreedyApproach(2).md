---
title: Lec.09_GreedyApproach(2)
author: khw
date: 2025-06-21
categories: [Exam, Algorithm]
tags: [2025_first_semester_final_exam]
pin: true
math: true
mermaid: true
---

# 그리디 알고리즘 핵심 정리: 스케줄링과 허프만 코딩

## 📚 전체 구성
**Chapter 4 (Part 2): The Greedy Approach**
- 4.1 최소 신장 트리 (Prim's, Kruskal's 알고리즘)
- 4.2 다익스트라 알고리즘 (단일 출발점 최단 경로)
- **4.3 스케줄링 문제**
- **4.4 허프만 코드**
- 4.5 배낭 문제: 그리디 vs 동적 계획법

---

## 🕐 4.3 스케줄링 문제 (Scheduling Problem)

### 기본 스케줄링 문제
**목표:** 시스템에서의 총 시간을 최소화
- **시스템 시간 = 대기 시간 + 서비스 시간**
- **응용 분야:**
  - 은행 창구 스케줄링
  - 디스크 드라이브 스케줄링  
  - 운영체제 스케줄러

### 마감시간이 있는 스케줄링 문제

#### 📋 문제 정의
- 모든 작업은 **동일한 시간**이 소요됨
- 각 작업은 **마감시간(deadline)** 과 **이익(profit)** 을 가짐
- 마감시간 이전에 시작해야 이익 획득 가능
- **목표: 총 이익 최대화**

#### 🔑 핵심 개념들

**1. 실행 가능한 순서 (Feasible Sequence)**
```
모든 작업이 각자의 마감시간 이전에 시작하는 순서
예) [4, 1]: 실행 가능, [1, 4]: 실행 불가능
```

**2. 실행 가능한 집합 (Feasible Set)**
```
최소 하나의 실행 가능한 순서가 존재하는 작업 집합
예) {1, 4}: 실행 가능한 집합, {2, 4}: 실행 불가능한 집합
```

**3. 최적 순서 (Optimal Sequence)**
```
실행 가능하면서 총 이익이 최대인 순서
```

#### 🚀 그리디 알고리즘 접근법

**단계별 알고리즘:**
1. **작업을 이익 기준으로 내림차순 정렬**
2. **각 작업을 순서대로 검사**
3. **실행 가능하면 스케줄에 추가**

```pseudocode
sort jobs in non-increasing order by profit;
S = ∅;
while (instance is not solved) {
    select next job;
    if (S is feasible with this job added)
        add this job to S;
    if (there are no more jobs)
        instance is solved;
}
```

#### 📊 실행 가능성 검사 방법

**핵심 보조정리:**
> 집합 S가 실행 가능 ⟺ S의 작업들을 마감시간 기준 오름차순으로 정렬한 순서가 실행 가능

**검사 과정:**
```
작업 집합 S = {1, 2, 4, 7}이 실행 가능한가?
→ 마감시간 순으로 정렬: [2, 7, 1, 4]
→ 각 위치에서 (위치 ≤ 마감시간) 확인
```

#### ⏱️ 시간 복잡도
- **기본 연산:** 정렬, 복사, 실행가능성 검사
- **입력 크기:** n (작업의 수)
- **각 반복에서:** 최대 (i-1) + i = 2i-1 번의 비교
- **총 복잡도:** W(n) = Σ(i=2 to n)[(i-1) + i] = n² - 1 ∈ **Θ(n²)**

---

## 📡 4.4 허프만 코드 (Huffman Code)

### 데이터 압축 문제

#### 🎯 문제 정의
**목표:** 파일을 가장 적은 비트 수로 인코딩하는 방법 찾기

**코드 유형:**
- **고정 길이 이진 코드:** 모든 문자에 동일한 비트 수 사용
- **가변 길이 이진 코드:** 문자마다 다른 비트 수 사용 (더 효율적)

#### 📈 효율성 비교 예시
```
파일: "ababcbbbbc", 문자 집합: {a, b, c}

고정 길이 코딩 (2비트):
a=00, b=01, c=10
총 비트: 18비트

가변 길이 코딩:
a=10, b=0, c=11  
총 비트: 13비트 (28% 절약!)
```

### 프리픽스 코드 (Prefix Code)

#### 🔐 특징
- **어떤 문자의 코드도 다른 문자 코드의 접두사가 되지 않음**
- **이진 트리로 표현 가능** (리프 노드 = 문자)
- **앞을 미리 보지 않고도 파싱 가능**

```
예시:
    O
   / \
  b   O
     / \
    a   c

코드: b=0, a=10, c=11
```

### 허프만 알고리즘

#### 🧮 알고리즘 과정
1. **문자들을 빈도수 기준으로 우선순위 큐에 배치**
2. **가장 빈도가 낮은 두 노드를 제거**
3. **새로운 내부 노드 생성 (빈도수 = 합)**
4. **새 노드를 큐에 삽입**
5. **노드가 하나 남을 때까지 반복**

```pseudocode
n = 문자 개수;
우선순위 큐에 n개의 노드 포인터 배치;
for (i = 1; i <= n - 1; i++) {
    remove(PQ, p);  // 최소 빈도
    remove(PQ, q);  // 두 번째 최소 빈도
    r = new nodetype;
    r->left = p;
    r->right = q;
    r->frequency = p->frequency + q->frequency;
    insert(PQ, r);
}
```

#### 📊 구체적 예시
```
입력: S = {a:16, b:5, c:12, d:17, e:10, f:25}

단계별 과정:
1. b:5, e:10 → 합치기 → 15
2. c:12, 15 → 합치기 → 27  
3. a:16, d:17 → 합치기 → 33
4. f:25, 27 → 합치기 → 52
5. 33, 52 → 합치기 → 85 (최종 트리)

최종 허프만 코드:
a=00, d=01, f=10, c=110, b=1110, e=1111
```

#### ⏱️ 시간 복잡도
- **우선순위 큐를 min-heap으로 구현**
- **각 힙 연산:** Θ(lg n)
- **전체 복잡도:** **Θ(n lg n)**

### 인코딩과 디코딩

#### 📤 인코딩 과정
1. **문자-코드 해시 테이블 생성**
2. **문자열을 순차적으로 이진 코드로 변환**

```cpp
void make_encoder(node_ptr node, string code, map<char, string> &encoder) {
    if (node->symbol != '+') { // 리프 노드
        encoder[node->symbol] = code;
    } else { // 내부 노드
        make_encoder(node->left, code + "0", encoder);
        make_encoder(node->right, code + "1", encoder);
    }
}
```

#### 📥 디코딩 과정
1. **이진 트리를 루트부터 순회**
2. **0이면 왼쪽, 1이면 오른쪽으로 이동**
3. **리프 노드에 도달하면 문자 출력하고 루트로 복귀**

```cpp
void decode(node_ptr root, node_ptr node, string s, int i) {
    if (i <= s.length()) {
        if (node->symbol != '+') { // 리프 노드
            cout << node->symbol;
            decode(root, root, s, i);
        } else { // 내부 노드
            if (s[i] == '0')
                decode(root, node->left, s, i + 1);
            else
                decode(root, node->right, s, i + 1);
        }
    }
}
```

### 최적성 보장

#### 🏆 허프만 알고리즘의 특징
- **항상 최적의 이진 코드를 생성함**
- **기반 보조정리:** 최적 이진 프리픽스 코드에 대응하는 이진 트리는 완전함 (모든 비리프 노드가 두 자식을 가짐)

#### 📈 압축 효과 계산
```
bits(T) = Σ(i=1 to n) frequency(vi) × depth(vi)

여기서:
- vi: i번째 문자
- frequency(vi): 문자 vi의 출현 빈도
- depth(vi): 트리에서 vi의 깊이
```

---

## 🎯 핵심 요약

### 그리디 알고리즘의 공통 특징
1. **각 단계에서 최선의 선택을 함**
2. **이전 선택을 되돌리지 않음**
3. **전역 최적해를 보장하는 문제들에 효과적**

### 학습한 두 알고리즘의 비교

| 특성 | 스케줄링 문제 | 허프만 코딩 |
|------|---------------|-------------|
| **목표** | 이익 최대화 | 압축률 최대화 |
| **그리디 기준** | 이익 순 정렬 | 최소 빈도 결합 |
| **시간 복잡도** | O(n²) | O(n lg n) |
| **자료구조** | 배열/리스트 | 우선순위 큐/힙 |
| **최적성** | 보장됨 | 보장됨 |

### 실무 응용
- **스케줄링:** 운영체제, 프로젝트 관리, 자원 할당
- **허프만 코딩:** 파일 압축, 네트워크 전송, 멀티미디어 처리