---
title: elec462-lecture-08-threads
author: khw
date: 2025-06-18
categories: [Exam, SystemProgramming]
tags: [2025_first_semester_final_exam]
pin: true
math: true
mermaid: true
---

## ELEC462 시스템 프로그래밍: 스레드와 동시성 함수 강의 요약

### **강의 전체 개요**

이 강의는 여러 작업이 동시에 실행되는 것처럼 보이는 **동시성(Concurrency)** 을 구현하는 핵심 기술인 **스레드**에 대해 배웁니다. 스레드는 강력하지만, 여러 스레드가 데이터를 공유할 때 발생하는 **경쟁 상태(Race Condition)** 와 같은 심각한 문제를 야기할 수 있습니다. 강의는 이러한 문제를 해결하기 위한 기본 동기화 프리미티브(Synchronization Primitives)인 **락(Locks)** 과 **조건 변수(Condition Variables)** 의 사용법과 내부 구현 원리를 설명하고, 이를 활용하여 안전하고 효율적인 동시성 데이터 구조를 만드는 방법을 다룹니다. 마지막으로, 동시성 프로그래밍에서 흔히 발생하는 **원자성 위반, 순서 위반, 교착 상태(Deadlock)** 와 같은 버그들의 원인과 해결책을 제시합니다.

---

### **Part 1: 스레드의 기본 개념 (Basic Concepts of Threads)**

첫 번째 파트에서는 동시성 프로그래밍의 기본 단위인 스레드에 대해 알아봅니다.

*   **스레드란?**: 스레드는 "하나의 실행 중인 프로세스를 위한 새로운 추상화"입니다. 단일 프로세스 내에서 여러 실행 흐름을 갖게 해줍니다. 각 스레드는 자신만의 **프로그램 카운터(PC), 레지스터 집합, 스택(Stack)** 을 가집니다.
*   **프로세스와의 차이점**: 가장 큰 차이점은 **메모리 공유**입니다. 한 프로세스 내의 모든 스레드는 **코드(Code), 데이터(Data), 힙(Heap) 영역을 공유**합니다. 이 덕분에 스레드 간 데이터 공유가 쉽고 효율적이지만, 바로 이 점 때문에 동기화 문제가 발생합니다.
*   **스레드 사용 이유**:
    1.  **병렬성(Parallelism)**: 멀티코어 CPU의 성능을 최대한 활용하여 프로그램을 더 빠르게 실행할 수 있습니다.
    2.  **느린 I/O 작업과의 중첩**: 한 스레드가 파일 읽기/쓰기나 네트워크 통신과 같은 느린 I/O 작업을 기다리는 동안, 다른 스레드는 CPU를 사용하여 다른 계산을 수행할 수 있어 프로그램의 전체적인 응답성과 효율성이 향상됩니다.
*   **스레드 생성과 실행의 비결정성**: `pthread_create`로 스레드를 생성하고 `pthread_join`으로 스레드가 끝나기를 기다릴 수 있습니다. 중요한 점은 OS 스케줄러에 의해 스레드들의 실행 순서가 결정되므로, 프로그램을 실행할 때마다 그 순서가 달라질 수 있다는 **비결정성(Unpredictability)** 입니다.
*   **핵심 문제: 공유 데이터와 경쟁 상태(Race Condition)**:
    `counter = counter + 1`과 같은 간단한 연산도 실제로는 여러 기계어 명령어(메모리에서 값을 레지스터로 **읽고**, 레지스터 값을 **증가시키고**, 레지스터 값을 다시 메모리에 **쓰는** 3단계)로 나뉩니다. 만약 한 스레드가 값을 읽고 증가시킨 후 메모리에 쓰기 전에 다른 스레드가 끼어들어 이전 값을 읽어 간다면, 연산 중 하나가 누락되어 최종 결과가 예상과 달라집니다. 이러한 상황을 **경쟁 상태**라고 합니다.
*   **용어 정리**:
    *   **임계 구역(Critical Section)**: 둘 이상의 스레드가 동시에 접근하면 안 되는 공유 자원(데이터)에 접근하는 코드 영역.
    *   **상호 배제(Mutual Exclusion)**: 한 번에 오직 하나의 스레드만 임계 구역에 들어갈 수 있도록 보장하는 것.
    *   **원자성(Atomicity)**: 임계 구역의 연산들이 마치 하나의 명령어처럼 중단 없이 실행되는 것을 보장하는 것. 이를 위해 **락**과 같은 동기화 기법이 필요합니다.

---

### **Part 2: 락 (Locks)**

두 번째 파트에서는 상호 배제를 보장하기 위한 가장 기본적인 도구인 락에 대해 다룹니다.

*   **락의 개념**: 락은 임계 구역을 보호하는 동기화 프리미티브입니다. 스레드는 임계 구역에 진입하기 전에 `lock()`을 호출하여 락을 획득하고, 임계 구역을 빠져나온 후 `unlock()`을 호출하여 락을 반환합니다. 오직 락을 획득한 스레드만이 임계 구역을 실행할 수 있습니다.
*   **락 구현의 어려움**:
    1.  **소프트웨어만으로 구현 시도**: 단순한 `flag` 변수를 사용한 락 구현은 `flag` 값을 확인하는(Test) 시점과 변경하는(Set) 시점 사이에 다른 스레드가 끼어들 수 있어 상호 배제를 보장하지 못합니다.
    2.  **하드웨어 지원의 필요성**: 이 문제를 해결하려면 `Test-And-Set`과 같은 **원자적 명령어(Atomic Instruction)**의 하드웨어 지원이 필수적입니다. 이 명령어는 특정 메모리 위치의 값을 읽는 동시에 새로운 값을 쓰는 작업을 중단 없이 한 번에 처리합니다.
*   **스핀락 (Spin Lock)**: `Test-And-Set`을 사용하여 락을 구현하면, 락을 얻지 못한 스레드는 락이 풀릴 때까지 `while` 루프를 돌며 계속 락 획득을 시도합니다. 이를 **스피닝(spinning)**이라 하며, CPU 자원을 낭비하는 단점이 있습니다.
*   **스피닝 문제 해결**:
    *   **Yielding**: 스피닝 대신 `yield()`를 호출하여 CPU를 다른 스레드에게 양보할 수 있지만, 불필요한 문맥 교환 비용이 발생하고 기아(starvation) 문제를 해결하지 못합니다.
    *   **큐를 이용한 수면(Sleeping)**: 가장 효율적인 방법입니다. 락을 얻지 못한 스레드는 대기 큐에 자신을 추가하고 잠드는(sleep) 상태가 됩니다. 락을 반납하는 스레드가 큐에서 기다리는 스레드를 깨워줍니다(`park`/`unpark` 시스템 콜 사용). 이 방법은 OS의 지원이 필요합니다.
*   **2단계 락 (Two-Phase Locks)**: 현대적인 리눅스 `futex` 등에서 사용하는 실용적인 접근법입니다. 처음에는 짧은 시간 동안 스핀하여 락 획득을 시도하고(락이 금방 풀릴 경우를 대비), 실패하면 잠드는 방식으로 전환하여 스핀락의 낮은 지연 시간과 수면 방식의 CPU 효율성을 모두 취합니다.

---

### **Part 3: 락 기반 동시성 데이터 구조 (Lock-based Concurrent Data Structures)**

세 번째 파트에서는 락을 사용하여 실제 데이터 구조를 스레드에 안전하게(thread-safe) 만드는 방법을 탐구합니다.

*   **단순 동기화 카운터의 문제점**: 카운터의 모든 연산(`increment`, `get` 등)을 단일 락으로 보호하면 정확성은 보장되지만, 스레드 수가 늘어날수록 락에 대한 경쟁이 심해져 **병목 현상(bottleneck)**이 발생하고 성능이 급격히 저하됩니다.
*   **성능 향상을 위한 근사 카운팅(Approximate Counting)**: 이 문제를 해결하기 위한 기법입니다.
    *   **아이디어**: 하나의 전역 카운터 대신, 여러 개의 **지역 카운터(local counter, CPU 코어마다 하나씩)**와 하나의 **전역 카운터(global counter)**를 둡니다.
    *   **동작 방식**: 각 스레드는 자기 코어의 지역 카운터 값을 증가시킵니다. 이 작업은 다른 코어의 스레드와 경쟁이 없어 매우 빠릅니다. 지역 카운터 값이 특정 임계값(S)에 도달하면, 전역 락을 잠그고 지역 카운터 값을 전역 카운터에 더한 후 지역 카운터를 0으로 초기화합니다.
    *   **장단점**: 임계값 S가 클수록 전역 락 경쟁이 줄어 성능(확장성)은 향상되지만, 전역 카운터 값의 정확도는 일시적으로 떨어집니다. S가 작으면 정확도는 높지만 성능은 저하됩니다. 이처럼 정확성과 성능 사이의 트레이드오프가 존재합니다.

---

### **Part 4: 조건 변수 (Condition Variables)**

네 번째 파트는 락만으로는 해결하기 어려운, "특정 조건이 만족될 때까지 기다리는" 동기화 문제를 다룹니다.

*   **조건 변수의 필요성**: 부모 스레드가 자식 스레드가 끝나기를 기다리거나, 소비자가 버퍼에 데이터가 채워지기를 기다리는 경우처럼, 단순히 임계 구역을 보호하는 것을 넘어 특정 **조건**을 기다려야 할 때가 있습니다. `while` 루프로 계속 확인(스피닝)하는 것은 비효율적입니다.
*   **조건 변수(CV)란?**: 스레드가 특정 조건이 참이 될 때까지 효율적으로 잠들고, 다른 스레드에 의해 조건이 충족되었을 때 깨어날 수 있게 해주는 동기화 도구입니다. **항상 락과 함께 사용됩니다.**
*   **핵심 연산**:
    *   `pthread_cond_wait(cv, lock)`: 호출되면 **원자적으로** (1) `lock`을 해제하고 (2) 스레드를 잠들게 합니다. 나중에 깨어나면 다시 `lock`을 획득하고 반환합니다. 락을 해제하는 이유는, 다른 스레드가 상태를 변경하고 `signal`을 보낼 수 있도록 하기 위함입니다.
    *   `pthread_cond_signal(cv)`: `wait`로 잠들어 있는 스레드 중 하나를 깨웁니다.
*   **`while` 루프의 중요성**: `wait`에서 깨어났다고 해서 조건이 반드시 참이라는 보장은 없습니다 (다른 스레드가 먼저 상태를 바꾸거나, Spurious Wakeup 등). 따라서 `wait` 호출은 **항상 `while` 루프 안에서** 사용하여 조건이 참인지 다시 확인해야 합니다.
*   **생산자-소비자 문제(Producer-Consumer Problem)**: CV를 설명하는 가장 대표적인 예제입니다.
    *   **문제**: 생산자는 버퍼가 가득 차면 기다려야 하고, 소비자는 버퍼가 비어 있으면 기다려야 합니다.
    *   **잘못된 해결책**: 하나의 CV만 사용하면, 소비자가 생산자를 깨워야 하는데 다른 소비자를 깨우는 등 의도치 않은 동작으로 교착 상태에 빠질 수 있습니다.
    *   **올바른 해결책**: `empty`와 `fill`이라는 **두 개의 CV를 사용**합니다.
        *   생산자는 버퍼가 가득 차면 `empty` CV를 기다리고, 아이템을 넣은 후에는 `fill` CV에 신호를 보냅니다.
        *   소비자는 버퍼가 비어 있으면 `fill` CV를 기다리고, 아이템을 꺼낸 후에는 `empty` CV에 신호를 보냅니다.
        *   이를 통해 생산자는 소비자를, 소비자는 생산자를 정확하게 깨울 수 있습니다.

---

### **Part 5: 흔한 동시성 문제들 (Common Concurrency Problems)**

마지막 파트에서는 실제 동시성 프로그램에서 자주 발생하는 버그의 유형과 해결책을 분석합니다.

*   **비-교착상태 버그 (Non-Deadlock Bugs)**:
    1.  **원자성 위반(Atomicity Violation)**: 원자적으로 실행되어야 할 코드 영역(예: `if (ptr != NULL) { ... use(ptr) ... }`)이 락으로 보호되지 않아 중간에 다른 스레드가 끼어들어 상태를 변경(예: `ptr = NULL`)하여 발생하는 버그입니다. **해결책: 해당 코드 영역 전체를 락으로 감쌉니다.**
    2.  **순서 위반(Order Violation)**: 두 메모리 접근 사이에 특정 실행 순서가 보장되어야 하는데(A가 B보다 먼저 실행), 이 순서가 강제되지 않아 발생하는 버그입니다. (예: 스레드 초기화 전에 스레드를 사용하려 할 때). **해결책: 조건 변수를 사용하여 특정 작업이 완료될 때까지 기다리도록 순서를 강제합니다.**

*   **교착 상태 버그 (Deadlock Bugs)**:
    *   **정의**: 두 개 이상의 스레드가 서로가 점유하고 있는 자원(락)을 기다리며 무한 대기에 빠지는 상황입니다. (예: 스레드1이 L1을 잡고 L2를 기다리고, 스레드2가 L2를 잡고 L1을 기다리는 순환 대기 상태)
    *   **발생 4가지 조건**: 상호 배제, 점유 및 대기(Hold-and-wait), 비선점(No Preemption), 순환 대기(Circular Wait). 이 중 하나라도 깨지면 교착 상태는 발생하지 않습니다.
    *   **예방(Prevention) 전략**:
        *   **순환 대기 깨기 (가장 실용적)**: 모든 락에 대해 **전역적인 순서(Total Lock Ordering)**를 정하고, 모든 스레드가 항상 그 순서대로 락을 획득하도록 강제합니다.
        *   **점유 및 대기 깨기**: 필요한 모든 락을 한 번에 원자적으로 획득합니다. 캡슐화를 깨고 동시성을 저해할 수 있어 실용성이 떨어집니다.
        *   **비선점 깨기**: `trylock()`을 사용합니다. 락 획득에 실패하면 이미 보유한 락을 모두 해제하고 나중에 다시 시도합니다. 이는 **라이브락(Livelock)**(스레드들이 계속 실패하고 재시도만 하며 진행은 못하는 상태)을 유발할 수 있으며, 랜덤 지연을 추가하여 해결할 수 있습니다.
    *   **회피(Avoidance)**: 스케줄러가 스레드들의 미래 락 요청 정보를 미리 알아서 교착 상태를 유발할 스케줄링을 피하는 방식입니다. 범용 OS에서는 비현실적입니다.
    *   **탐지 및 복구(Detect and Recover)**: 교착 상태 발생을 허용하되, 주기적으로 자원 할당 그래프에서 사이클을 탐지하여 교착 상태를 발견하면 관련 프로세스 중 하나를 강제 종료하여 복구하는 방식입니다. 주로 데이터베이스 시스템에서 사용됩니다.

이 강의는 스레드라는 강력한 도구를 올바르게 사용하여, 현대 멀티코어 환경에서 빠르고 안정적인 프로그램을 개발하는 데 필요한 핵심적인 지식과 원칙을 제공합니다.
