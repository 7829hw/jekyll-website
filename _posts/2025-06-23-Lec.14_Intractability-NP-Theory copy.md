---
title: Algorithm_final_summary
author: khw
date: 2025-06-23
categories: [Exam, Algorithm]
tags: [2025_first_semester_final_exam]
pin: true
math: true
mermaid: true
---

# 알고리즘실습 핵심 개념 정리

## 1. 그리디 알고리즘 (Greedy Approach)

### 1.1 기본 원리
- **그리디 선택**: 각 단계에서 지역 최적해를 선택
- **최적 부분구조**: 전체 문제의 최적해가 부분 문제의 최적해를 포함
- **적용 조건**: 그리디 선택이 전역 최적해를 보장하는 경우

### 1.2 주요 알고리즘

#### Scheduling with Deadlines (Algorithm 4.4)
- **핵심 아이디어**: 데드라인 기준 오름차순 정렬 후 feasible 확인
- **시간복잡도**: O(n²)
- **구현 포인트**: 
  - K sequence에 작업을 하나씩 추가
  - feasible 여부 확인 후 유지/제거 결정

#### 허프만 알고리즘 (Huffman's Algorithm)
- **목적**: 최적 이진 문자 코드 생성
- **핵심 구조**:
  - 우선순위 큐(최소힙) 사용
  - 빈도수가 낮은 노드부터 병합
  - 왼쪽 자식: 0, 오른쪽 자식: 1
- **시간복잡도**: O(n log n)
- **인코딩**: 루트에서 리프까지의 경로
- **디코딩**: 루트부터 시작하여 0/1에 따라 이동

#### 제켄도르프 분해 (Zekendorf's Decomposition)
- **정리**: 모든 양의 정수는 인접하지 않은 피보나치 수의 합으로 유일 표현
- **그리디 방법**: 가장 큰 피보나치 수부터 차례로 빼기

---

## 2. 백트래킹 (Backtracking)

### 2.1 기본 원리
- **상태공간트리**: 가능한 후보 해들의 트리 구조
- **가지치기**: promising() 함수로 불필요한 탐색 제거
- **깊이우선탐색**: DFS 방식으로 해공간 탐색

### 2.2 주요 문제들

#### N-Queens 문제 (Algorithm 5.1)
- **핵심 함수**: queens(int i)
- **promising 조건**:
  - 같은 열에 퀸이 없어야 함
  - 대각선상에 퀸이 없어야 함
- **상태공간**: 각 레벨은 행, 각 노드는 열 위치

#### 기사의 여행 (Knight's Tour)
- **목표**: 체스판의 모든 칸을 한 번씩 방문
- **Hamiltonian Circuit**: 출발점으로 돌아오는 경로
- **Hamiltonian Path**: 출발점으로 돌아오지 않는 경로

#### 부분집합의 합 (Sum-of-Subsets) (Algorithm 5.4)
- **목표**: 주어진 집합에서 합이 W인 부분집합 찾기
- **상태공간트리**:
  - 레벨 i: i번째 원소의 포함/미포함 결정
  - 왼쪽 자식: 포함, 오른쪽 자식: 미포함
- **가지치기 조건**:
  - 현재까지의 합 > W
  - 현재까지의 합 + 남은 원소들의 합 < W

#### 0-1 배낭문제 (Backtracking) (Algorithm 5.7)
- **상태**: (level, profit, weight, maxprofit, promising)
- **maxprofit 계산**: 현재 이익 + 남은 아이템들의 fractional knapsack 해
- **가지치기**: maxprofit ≤ 현재 최적해

---

## 3. 동적계획법 (Dynamic Programming)

### 3.1 기본 원리
- **최적성의 원리**: 최적해의 부분해도 최적
- **중복 부분문제**: 같은 부분문제가 반복적으로 발생
- **메모이제이션**: 계산 결과를 테이블에 저장

### 3.2 주요 문제들

#### TSP 동적계획법 (Algorithm 3.11)
- **D[i][A]**: 정점 i에서 시작하여 집합 A의 모든 정점을 거쳐 v1으로 가는 최단거리
- **점화식**:
  - D[i][∅] = W[i][1] (기저 조건)
  - D[i][A] = min{W[i][j] + D[j][A-{j}] | j ∈ A}
- **시간복잡도**: O(n² × 2ⁿ)

#### 배낭문제 비교
- **Fractional Knapsack**:
  - 그리디로 해결 가능
  - 가치/무게 비율 기준 정렬
- **0-1 Knapsack**:
  - 동적계획법 필요
  - DP[i][w] = i번째까지 아이템으로 무게 w일 때 최대 가치

---

## 4. 분기한정법 (Branch-and-Bound)

### 4.1 기본 원리
- **분기**: 문제를 부분문제로 나누기
- **한정**: bound 함수로 탐색 영역 제한
- **우선순위**: best-first 또는 breadth-first 탐색

### 4.2 주요 알고리즘

#### 0-1 배낭문제 (Branch-and-Bound) (Algorithm 6.2)
- **우선순위 큐 사용**: bound 값이 큰 노드부터 탐색
- **bound 계산**: 현재 이익 + fractional knapsack으로 계산한 상한값
- **노드 구조**: (level, profit, weight, bound)
- **가지치기**: bound ≤ 현재 최적해

#### TSP 분기한정법
- **bound 계산**: 현재 경로 비용 + MST 기반 하한값
- **상태공간트리**: 각 레벨은 다음 방문할 정점 선택
- **효율성**: 전체 상태공간의 일부만 탐색하여 최적해 발견

---

## 5. 계산복잡도 이론

### 5.1 복잡도 클래스

#### P 클래스
- **정의**: 다항 시간에 해결 가능한 결정 문제들
- **특징**: 효율적으로 해결 가능
- **예시**: 정렬, 최단경로, MST

#### NP 클래스
- **정의**: 비결정적 다항 시간에 해결 가능한 결정 문제들
- **특징**: 해의 검증은 다항 시간에 가능
- **예시**: 3-SAT, Hamiltonian Circuit, 0-1 Knapsack

#### NP-Complete
- **정의**: NP에 속하면서 모든 NP 문제로부터 다항 시간 변환 가능
- **특징**: 가장 어려운 NP 문제들
- **예시**: 3-SAT, Clique, Vertex Cover

#### NP-Hard
- **정의**: 모든 NP 문제로부터 다항 시간 변환 가능 (NP 소속 불필요)
- **특징**: 최적화 문제들이 주로 속함
- **예시**: TSP, 0-1 Knapsack

### 5.2 중요한 문제들

#### 정지문제 (Halting Problem)
- **정의**: 주어진 프로그램이 유한 시간 내에 정지하는지 판별
- **결과**: 튜링머신으로도 해결 불가능한 문제 (계산 불가능)
- **의미**: 알고리즘으로 해결할 수 없는 문제의 존재 증명

#### Selection Problem & Adversary Argument
- **목표**: 최솟값/최댓값 찾기에 필요한 최소 비교 횟수
- **적대적 논증**: 최악의 경우를 고려한 하한값 증명
- **결과**:
  - n개 원소에서 최솟값: n-1번 비교
  - n개 원소에서 최솟값과 최댓값: ⌈3n/2⌉-2번 비교

### 5.3 Input Size의 중요성

**소수 판별 예시**:
- 알고리즘: 2부터 √N까지 모든 수로 나누어보기
- 연산 횟수: O(√N)
- Input Size: log N (N을 표현하는 비트 수)
- 실제 복잡도: O(2^(s/2)) where s = log N
- 결론: 다항 시간 알고리즘이 아님!

---

## 6. 근사 알고리즘 (Approximation Algorithms)

### 6.1 TSP 근사 알고리즘
**접근법**:
1. Kruskal 알고리즘으로 MST 구성
2. MST를 DFS로 순회하여 투어 생성
3. 삼각부등법(Triangle Inequality) 적용하여 경로 단축

- **성능 보장**: 최적해의 2배 이내
- **조건**: 메트릭 TSP (삼각부등법 만족)

### 6.2 Bin Packing 근사 알고리즘
- **First-Fit**: 첫 번째로 들어갈 수 있는 bin에 배치
- **First-Fit Decreasing**: 크기 순으로 정렬 후 First-Fit 적용
- **성능 비율**: 최적해의 11/9배 이내

---

## 7. 실전 문제 해결 전략

### 7.1 알고리즘 선택 기준
- **그리디**: 지역 최적해 = 전역 최적해인 경우
- **백트래킹**: 모든 해를 체계적으로 탐색, 가지치기 가능
- **동적계획법**: 최적 부분구조 + 중복 부분문제
- **분기한정법**: 최적화 문제, bound 함수 계산 가능

### 7.2 시간복잡도 분석
- **백트래킹**: O(2ⁿ) ~ O(n!), 가지치기로 개선
- **동적계획법**: O(poly(n)), 상태 수 × 전이 시간
- **분기한정법**: 평균적으로 전체 탐색보다 효율적
- **그리디**: 대부분 O(n log n), 정렬이 병목

### 7.3 공간복잡도 고려사항
- **동적계획법**: 테이블 크기가 중요 (O(2ⁿ) 가능)
- **백트래킹**: 재귀 깊이 = O(n)
- **분기한정법**: 우선순위 큐 크기
- **그리디**: 일반적으로 O(1) ~ O(n)