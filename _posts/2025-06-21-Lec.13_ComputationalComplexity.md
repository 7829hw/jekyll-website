---
title: Lec.13_ComputationalComplexity
author: khw
date: 2025-06-21
categories: [Exam, Algorithm]
tags: [2025_first_semester_final_exam]
pin: true
math: true
mermaid: true
---

# 계산 복잡도와 선택 문제 핵심 정리

## 1. 계산 복잡도(Computational Complexity) 기본 개념

### 문제 해결의 두 가지 접근법
- **효율적인 알고리즘 개발**: 주어진 문제에 대해 더 빠른 알고리즘을 찾는 것
- **효율성 한계 증명**: 더 효율적인 알고리즘이 불가능함을 수학적으로 증명하는 것

### 계산 복잡도의 목표
- 주어진 문제에 대해 **하한(lower bound) Ω(f(n))** 결정
- 해당 문제에 대해 **Θ(f(n)) 알고리즘** 개발
- 이를 통해 알고리즘의 개선 가능성을 판단

### 정렬 문제 예시
- **Exchange Sort**: Θ(n²) 시간 복잡도
- **Quicksort**: Θ(n lg n) 평균 시간 복잡도
- **하한 증명**: 비교 기반 정렬은 Θ(n lg n)보다 빠를 수 없음

## 2. 선택 문제(Selection Problem)

### 선택 문제의 정의
정렬되지 않은 n개의 키에서 **k번째로 작은(또는 큰) 키**를 찾는 문제

### 2.1 가장 큰 키 찾기
```cpp
// Algorithm 8.2: 가장 큰 키 찾기
void find_largest(int n, vector<int> S, int& large) {
    large = S[1];
    for (i = 2; i <= n; i++)
        if (S[i] > large)
            large = S[i];
}
```
- **시간 복잡도**: T(n) = n-1 (비교 횟수)
- **정리 8.7**: 결정적 알고리즘으로 n개 키 중 가장 큰 값을 찾으려면 최소 n-1번의 비교가 필요

### 2.2 가장 크고 작은 키 동시에 찾기

#### 단순한 접근법 (Algorithm 8.3)
- **최악의 경우**: W(n) = 2n-2 비교
- 각 키를 small, large와 순차적으로 비교

#### 개선된 접근법 (Algorithm 8.4) - 키 쌍 만들기
**핵심 아이디어**: 키들을 쌍으로 묶어서 먼저 비교한 후, 작은 것들 중에서 최솟값, 큰 것들 중에서 최댓값을 찾기

**시간 복잡도**:
- n이 짝수일 때: T(n) = 3n/2 - 2
- n이 홀수일 때: T(n) = 3n/2 - 3/2

**정리 8.8**: 이것이 최적이며, 더 빠른 알고리즘은 존재하지 않음

### 2.3 두 번째로 큰 키 찾기

#### 토너먼트 방법
- **1단계**: 토너먼트 방식으로 가장 큰 키 찾기 (n-1 비교)
- **2단계**: 가장 큰 키에게 진 키들 중에서 가장 큰 키 찾기 (lg n - 1 비교)
- **총 시간 복잡도**: T(n) = n + lg n - 2

## 3. 적대적 논증(Adversary Argument)

### 적대적 논증의 개념
알고리즘을 **가능한 한 오래 작동시키기 위해** 각 결정 시점에서 최악의 답을 제공하는 기법

### 키의 상태 분류
- **X**: 아직 비교에 참여하지 않은 상태 (정보량: 0)
- **L**: 적어도 한 번 졌고 이긴 적이 없는 상태 (정보량: 1)
- **W**: 적어도 한 번 이겼고 진 적이 없는 상태 (정보량: 1)
- **WL**: 적어도 한 번 이기고 한 번 진 상태 (정보량: 2)

### 적대자의 전략
- **목표**: 각 비교에서 가능한 한 적은 정보를 제공
- **원칙**: 이전 답변과 일관성을 유지하면서 최대한 많은 가능성을 남겨둠
- **결과**: 알고리즘이 2n-2번의 비교를 강제로 수행하도록 만듦

## 4. k번째 작은 키 찾기 알고리즘들

### 4.1 정렬을 이용한 방법
```cpp
sort(S.begin(), S.end());
return S[k];
```
- **시간 복잡도**: Θ(n lg n)
- 단순하지만 비효율적

### 4.2 분할을 이용한 선택 (Algorithm 8.5)
**QuickSort의 분할 기법 활용**
```cpp
int selection(int low, int high, int k) {
    if (low == high) return S[low];
    partition(low, high, pivotpoint);
    if (k == pivotpoint) return S[pivotpoint];
    else if (k < pivotpoint) 
        return selection(low, pivotpoint-1, k);
    else return selection(pivotpoint+1, high, k);
}
```
- **최악의 경우**: W(n) = n(n-1)/2 (피벗이 계속 극단값일 때)
- **평균적인 경우**: A(n) < 3n ∈ Θ(n)

### 4.3 중간값의 중간값을 이용한 선택 (Algorithm 8.6)

#### 핵심 아이디어
1. **5개씩 그룹 분할**: n개 키를 n/5개 그룹으로 나눔
2. **각 그룹의 중간값 찾기**: 6번의 비교로 5개 중 중간값 추출
3. **중간값들의 중간값 찾기**: 재귀적으로 n/5개 중간값의 중간값 구함
4. **분할 수행**: 구한 값을 피벗으로 사용

#### 시간 복잡도 분석
- **재귀 호출 크기**: 최대 7n/10 - 3/2
- **점화식**: W(n) = W(7n/10) + W(n/5) + 11n/5
- **결과**: W(n) ≤ 22n ∈ Θ(n)
- **중요한 성과**: **최악의 경우에도 선형 시간!**

### 4.4 확률적 선택 (Algorithm 8.7)

#### Sherwood 알고리즘
- **피벗 선택**: 균등 분포로 무작위 선택
- **장점**: 구현이 간단하고 실제로 빠름
- **기댓값 시간 복잡도**: E(n,k) ≤ 4n ∈ Θ(n)
- **특징**: k값에 독립적으로 선형 시간

## 5. 확률적 알고리즘의 분류

### 5.1 Monte Carlo 알고리즘
- **특징**: 정확한 답을 보장하지 않음
- **용도**: 근사값이나 추정값 제공
- **예시**: 수치 적분, 최적화 문제

### 5.2 Sherwood 알고리즘
- **특징**: 항상 정확한 답을 제공
- **목적**: 평균 성능이 최악 성능보다 훨씬 좋은 결정적 알고리즘의 성능 개선
- **예시**: 확률적 QuickSort, 확률적 선택

### 5.3 Las Vegas 알고리즘
- **특징**: 정확한 답을 제공하지만 때로는 해를 못 찾을 수도 있음
- **용도**: 복잡한 조합 최적화 문제
- **예시**: 8-Queens 문제 해결

## 6. 성능 비교 및 실용적 고려사항

### 알고리즘별 성능 요약

| 알고리즘 | 최악의 경우 | 평균적인 경우 | 구현 복잡도 |
|---------|------------|-------------|------------|
| 정렬 후 선택 | Θ(n lg n) | Θ(n lg n) | 매우 쉬움 |
| 분할 선택 | Θ(n²) | Θ(n) | 쉬움 |
| 중간값의 중간값 | Θ(n) | Θ(n) | 복잡함 |
| 확률적 선택 | Θ(n²) | Θ(n) | 쉬움 |

### 실제 사용 권장사항
1. **작은 데이터셋 (n < 1000)**: 정렬 후 선택도 충분히 빠름
2. **일반적인 경우**: 확률적 선택이 구현이 쉽고 실제로 빠름
3. **최악의 경우 성능 보장 필요**: 중간값의 중간값 알고리즘 사용
4. **반복적 선택이 필요한 경우**: 한 번 정렬 후 여러 번 선택

## 7. 이론적 의의와 응용

### 계산 복잡도론에서의 의의
- **하한 증명 기법**: 적대적 논증은 다른 문제들의 하한 증명에도 활용
- **최적 알고리즘**: 이론적 하한과 일치하는 알고리즘 개발의 중요성
- **확률적 방법**: 최악의 경우와 평균적인 경우의 트레이드오프

### 실제 응용 분야
- **데이터베이스**: ORDER BY와 TOP-K 쿼리 최적화
- **통계 처리**: 중간값, 분위수 계산
- **실시간 시스템**: 최악의 경우 성능 보장이 중요한 시스템
- **빅데이터**: 대용량 데이터에서의 효율적인 선택 연산

이러한 알고리즘들은 현대 컴퓨터 과학의 기반이 되는 중요한 이론적 성과들이며, 실제 시스템에서도 광범위하게 활용되고 있습니다.